# 高级Java学习笔记
> 余洋军-20190301

## Java高级-高性能编程专题
### 第一章 多线性并发编程
#### 第一节 Java基础
##### 1.1.1 Java程序运行原理分析
- major version: JDK5,6,7,8分别对应49,50,51,52
##### 1.1.2 线程状态
- New
- Runnable
- Blocked
- Waiting
- Timed Waiting
- Terminated
##### 1.1.3 线程中止
- stop:中止线程，并且清除监控器锁的信息，但可能导致线程安全问题，JDK不建议使用
- destroy:JDK未实现
##### 1.1.4 内存屏障和CPU缓存
- CPU性能优化手段-缓存，为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。处理器大多会利用缓存以提高性能。
- 缓存同步协议，MESI协议规定每条缓存有个状态位，同时定义了四个状态。多个处理器时，单个cpu对缓存中数据进行了改动，需要通知其它cpu。
- [ ] 修改态(Modified)-此cache行已被修改过，内容已不同于主存，为此cache专有。
- [ ] 专有态(Exclusive)-此cache行内容同于主存，但不出现于其它cache中。
- [ ] 共享态(Shared)-此cache行内容同于主存，但也出现于其它cache中。
- [ ] 无效态(Invalid)-此cache行内容无效。
- 运行时指令重排：当cpu写缓存时发现缓存区块正被其他cpu占用，为了提高cpu处理性能，可能将后面的读缓存命令优先执行。as-is-serail编译器和处理器不会对存在数据依赖关系的操作做重排。
- 内存屏障
- [ ] 写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，cpu就不会因为性能考虑而对指令重排。
- [ ] 读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从主内存中加载数据。让cpu缓存与主内存保持一致，避免了缓存导致的一致性问题。
##### 1.1.5 线程通信
- 文件共享
- 网络共享
- 共享变量
- JDK提供的线程协调API:suppend/resum、wait/notify、park/unpark

susppend/resum | wait/notify | park/upark
---|---|---
有序|有序|无序
有死锁|无死锁|有死锁
- 伪唤醒：处于等待状态的线程可能会收到错误警报和伪唤醒，所以应该使用循环来检查等待条件。
##### 1.1.6 线程封闭
- 多线程访问共享可变数据时，涉及到线程间数据同步的问题。并不是所有时候，都要用到共享数据，如果数据都被封闭在各自线程中，就不需要同步。线程封闭具体的体现有：ThreadLocal、局部变量。
- 


#### 第二节 线程安全问题
##### 1.2.1 线程安全这可见性问题
- 指令重排序：Java编程语言的语义允许编译器和微处理器执行优化，这些优化可以与不正确的同步代码交互，从而产生看似矛盾的行为。
- 关闭JIT优化 -Djava.compiler=NONE
- Java编程语言内存模型通过检查执行跟踪中的每个 读操作，并根据某些规则检查该操作观察到写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存砸开预测。
- 对于同步的规则定义：
- [ ] 对于监视器m的解锁与所有后续操作对于m的加锁同步
- [ ] 对volatile变量v的写入，与所有其他线程后续对v的读同步
- [ ] 启动线程的操作与线程中的第一个操作同步
- [ ] 对于每个属性写入默认值(0, false, null)与每个线程对其操作同步
- [ ] 线程T1的最后操作与线程T2发现线程T1已经结束同步
- [ ] 如果线程T1中断了T2，那么线程T1的中断操作与其他所有线程发现T2被中断同步
- Happens-before先行发生原则：happens-before关系主要用于强调两个有冲突的动作之间的顺序，以及定义数据争用的发生时机。遵守这个原则，也就意味着有些代码不能进行重排
- [ ] 某个线程中的每个动作都happens-before该线程中该动作后面的动作
- [ ] 某个Monitor上的unlock动作都happens-before同一个Monitor上后续的lock动作
- [ ] 对某个volatile字段的写操作都happens-before每个后续对该volatile字段的操作
- [ ] 在某个线程对象上调用start()方法都happens-before该启动了线程中的任意动作
- [ ] 某个线程中的所有动作happens-before任意其他线程成功从该纯种对象的join()中返回
- [ ] happens-before 具有传递性
- final在JVM中的处理：
- [ ] final在该对象的构造方法中设置对象的字段，当线程看到该对象时，将始终看到该对象的final字段的正确构造版本
- [ ] 如果在构造方法中设置字段后发生读取，则会看到该fianl字段分配的值，否则将看到默认值
- [ ] 读取该共享对象的final成员变量之前，先要读取共享对象
- [ ] 通过static是不可修改的字段。然而 System.in、System.out和System.error是static final字段，遗留原因，必须允许通过set方法改变，将这些字段称为写保护，以区别普通final字段。
- 在虚拟机规范中，写64位的double和long分成了两次32位值的操作，读写volatile的long和double总是原子的，商业JVM都实现了原子性
- ##### 1.2.2 线程安全之原子操作
- volatile关键字
- [ ] 可见性问题：让一个线程共享变量的修改，能够及时的被其他线程可见
- [ ] 禁止缓存
- [ ] 不做指令重排
- 竞态条件与临界区
- [ ] 临界区：incr方法内部就是临界区域，关键部分代码的多线程并发执行，会对执行结果产生影响
- [ ] 竞态条件：可能发生在临界区域的特殊条件。多线程执行incr方法中i++关键代码进，产生了竞态条件
- 共享资源
- [ ] 如果一段代码线程安全的，则不会包含竞态条件
- [ ] 栈封闭时，不会在线程之间共享的变量，都是线程安全
- [ ] 局部对象引用本身不共享，但是引用的对象存储在共享堆中。如果方法内创建的对象，只是在方法中传递，并且不对其他线程可用，那么也是线程安全的
- [ ] 不可变对象，在对象创建后就不会再被修改，从而实现线程安全
- [ ] 判定规则：如果创建、使用和处理资源，永远不会逃脱单个线程的控制，该资源是线程安全的
- CAS机制：Compare and swap 比较和交换。属于硬件同步原语，处理器保证了基本内存操作的原子性
- JDK1.8更新
- [ ] 更新器：DoubleAccumulator、LongAccumulator
- [ ] 计数器：DoubleAdder、LongAdder
- CAS的三个问题：
- [ ] 循环+CAS,自旋的实现让所有线程都处于高频运行，争抢CPU执行时间的状态。如果操作长时间不成功，会带来很大CPU资源消耗
- [ ] 仅针对单个变量的操作，不能用于多个变量来实现原子操作
- [ ] ABA问题
##### 1.2.3 Java锁相关
- 自旋锁：为了不放弃CPU执行事件，循环的使用CAS技术对数据尝试进行更新，直至成功
- 悲观锁：假定会发生冲突，同步所有对数据的相关操作，从读数据就开始上锁
- 乐观锁：假定没有冲突，在修改数据如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改
- 独享锁（写）：给资源加上写锁，线程能修改资源，其他线程不能再加锁（单写）
- 共享锁（读）：给资源加上读锁只能读不能修改，其他线程也只能加读锁，不能加写锁（多读）
- 可重入|不可重入锁：线程拿到一把锁之后，可能自由进入同一把锁所同步的其他代码
- 公平|非公平锁：争抢锁的有序称为公平锁
- 同步关键字synchronized特性：可重入、独享、悲观锁。锁的范围：类锁、对象类、锁消除、锁粗化
- jitwatch工具
- [ ] 下载地址 https://github.com/AdoptOpenJDK/jitwatch
- [ ] Run Configuration里配置JVM参数 -server -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading  -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log
- [ ] 未锁定->偏向锁->轻量锁->重量锁
- [ ] 偏向锁到轻量锁：偏向锁本质就是无锁，如没发生过任何线程争抢锁的情况，JVM认为是单线程操作，无需做同步
- [ ] 重量级锁-监视器（monitor）修改mark work如果失败，会自旋CAS一定次数，该次数可能通过参数配置，超过次数，仍未抢到锁，则锁升级为重量级锁，进入阻塞
#### 第三节 J.U.C并发编程包详解
##### 1.3.1 AQS抽象队列同步
- Lock接口的实现，具备和同步关键字同样的内存语义
- ReadWriteLock维护一对关联锁，一个用于只读操作，一个用于写入
- 同步锁的本质-排队
- [ ] 同步的方式：独享锁-单个队列窗口，共享锁-多个队列窗口
- [ ] 抢锁的方式：公平，非公平
- [ ] 没抢到锁的处理方式：快速尝试多次(CAS自旋)，阻塞等待
- [ ] 唤醒阻塞线程的方式(叫号器)：全部通知，通知下一个
- AQS抽象队列同步器：提供了对资源占用、释放、线程等待、唤醒等接口和具体实现

##### 1.3.2 并发容器类1
- Map
- Set

##### 1.3.3 并发容器类2
- List
- [ ] CopyOnWriteArrayList和ArrayList比较，优点是并发安全，缺点是：1，多了内存占用，写数据是Copy一份完整的数据，单独进行操作，占用两份内存。1，数据一致性，数据写完之后，其他线程不一定是马上读取最新内容
- Queue

##### 1.3.4 Fork/Join框架
